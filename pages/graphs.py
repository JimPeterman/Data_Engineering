import pickle# import matplotlib.pyplot as pltimport streamlit as stimport plotly.express as pximport plotly.graph_objs as godef app():    st.write('''    ## Explore Trends in the Data from FRIEND        On this page, you can explore trends in fitness or other \    health metrics.        At this time, we're only displaying trends from the US, but check back \    later for global trends!    ''')            # Create a function for plotting.    def line(error_y_mode=None, **kwargs):        """        Found this function on Stack Overflow to add error bands/bars.        https://stackoverflow.com/questions/69587547/continuous-error-band-with-plotly-express-in-python        This will also graph with a hover info bar with the values (so they        don't have to be printed).        I changed the background color and what's displayed in the hover info.                Extension of `plotly.express.line` to use error bands."""                ERROR_MODES = {'bar','band','bars','bands',None}        if error_y_mode not in ERROR_MODES:            raise ValueError(f"'error_y_mode' must be one of {ERROR_MODES}, received {repr(error_y_mode)}.")        if error_y_mode in {'bar','bars',None}:            fig = px.line(**kwargs)        elif error_y_mode in {'band','bands'}:            if 'error_y' not in kwargs:                raise ValueError(f"If you provide argument 'error_y_mode' you must also provide 'error_y'.")            figure_with_error_bars = px.line(**kwargs)            fig = px.line(**{arg: val for arg,val in kwargs.items() if arg != 'error_y'},                        template="simple_white") # Just white background.            for data in figure_with_error_bars.data:                x = list(data['x'])                y_upper = list(data['y'] + data['error_y']['array'])                y_lower = list(data['y'] - data['error_y']['array'] if data['error_y']['arrayminus'] is None else data['y'] - data['error_y']['arrayminus'])                color = f"rgba({tuple(int(data['line']['color'].lstrip('#')[i:i+2], 16) for i in (0, 2, 4))},.3)".replace('((','(').replace('),',',').replace(' ','')                fig.add_trace(                    go.Scatter(                        x = x+x[::-1],                        y = y_upper+y_lower[::-1],                        fill = 'toself',                        fillcolor = color,                        line = dict(                            color = 'rgba(255,255,255,0)'                        ),                        hoverinfo = "skip",                        showlegend = False,                        legendgroup = data['legendgroup'],                        xaxis = data['xaxis'],                        yaxis = data['yaxis'],                    )                )            # Reorder data as said here: https://stackoverflow.com/a/66854398/8849755            reordered_data = []            for i in range(int(len(fig.data)/2)):                reordered_data.append(fig.data[i+int(len(fig.data)/2)])                reordered_data.append(fig.data[i])            fig.data = tuple(reordered_data)                        # Update so hover trace only gives var_int.            fig.update_traces(mode="markers+lines", hovertemplate=None)            # Update so hover trace presents for all lines.            fig.update_layout(hovermode="x")            # Drop the legend title.            fig.update_layout(legend={'title_text':''})            return fig                    ###### Create summary line graphs for VO2max metrics.    st.write('''    ### Fitness (VO2max) trends:    ''')        col1, col2 = st.columns(2)        with col1:                comp_pick = st.radio("What comparison are you interested in?",                              ("Male vs. Female", "Treadmill vs. Cycling",                               "Healthy vs. Cardiovascular Disease",                              "US Regions"), index=0)        # If no regions/categories are selected below, there's an error.        # So, use that to determine if graphed. Start by assigning blank.                regions, cvd_categories = [], []        if "Regions" in comp_pick:            # Only display options for regions with >500 tests.            # Import list of regions with <500 tests.            region_low_cts = open('./data/line_graph_region_counts.txt',"r").read()            region_low_cts = region_low_cts.split("\n")            # with open('./data/line_graph_region_counts.txt', 'rb') as to_read:            #     region_low_cts = pickle.load(to_read)            region_full = ["Midwest", "Northeast", "South", "West", "Pacific"]            region_options = [x for x in region_full if x not in region_low_cts]            # Use the options in the select box.            regions = st.multiselect("What regions are you intersted in? (Select\                                     all regions of interest).",                                     region_options)            # Print what regions are not included so users can know.            lst = ["**Region(s) not included due to <500 tests:"]                        for region in region_low_cts:                lst.append(region)            st.write(" ".join(lst))                        int_in_cvd_cat = "No"        if "Healthy" in comp_pick:            int_in_cvd_cat = st.radio("Do you want to view individual \                                  cardiovascular disease categories?",                                   ("Yes", "No"), index=1)                        if int_in_cvd_cat == "Yes":                                cvd_dct = {                    "Healthy": "Healthy",                     "Myocardial Infarction (MI)": "MI",                     "Percutaneous Coronary Intervention (PCI)":"PCI",                     "Coronary Artery Bypass Graft Surgery (CABG)":"CABG",                     "Heart Failure (HF)":"HF"                }                cvd_categories = st.multiselect("What cardiovascular disease \                                        categories are you intersted in? \                                        (Select all categories of interest).",                                        list(cvd_dct.keys()))                cvd_categories = [v for k,v in cvd_dct.items() if k in cvd_categories]                    # Import the appropriate summary data.             if int_in_cvd_cat == "Yes":            with open('./data/line_graph_modes_cvd_specific.pickle', 'rb') as to_read:                df = pickle.load(to_read)            # Filter to the CVD categories of interest.            df = df[df.CVDcategory.isin(cvd_categories)]        elif "Healthy" in comp_pick:            with open('./data/line_graph_modes_cvd.pickle', 'rb') as to_read:                df = pickle.load(to_read)        elif "Regions" in comp_pick:            with open('./data/line_graph_modes_region.pickle', 'rb') as to_read:                df = pickle.load(to_read)             # Filter to the regions of interest.            df = df[df.CensusRegion.isin(regions)]        else:            with open('./data/line_graph_modes_separate.pickle', 'rb') as to_read:                df = pickle.load(to_read)                        with col2:        # Get the grouping variables.        if "Male" in comp_pick:            grp_pick = st.radio("Are you interested in treadmill tests or cycling\                                tests?", ("Treadmill", "Cycling"), index=0)            if "Treadmill" in grp_pick:                df_avg = df.query("ExMode == 'Treadmill'")            else:                df_avg = df.query("ExMode == 'Cycling'")                            elif "Treadmill" in comp_pick:            grp_pick = st.radio("Are you interested in data from males or\                                females?", ("Males", "Females"), index=0)            if "Males" in grp_pick:                df_avg = df.query("Sex == 'Male'")            elif "Females" in grp_pick:                df_avg = df.query("Sex == 'Female'")                             else:            grp_pick = st.radio("Are you interested in treadmill tests or cycling\                                tests?", ("Treadmill", "Cycling"), index=0)            if "Treadmill" in grp_pick:                df_avg = df.query("ExMode == 'Treadmill'")            else:                df_avg = df.query("ExMode == 'Cycling'")                         grp_pick2 = st.radio("Are you interested in data from males or\                                females?", ("Males", "Females"), index=0)            if "Males" in grp_pick2:                df_avg = df_avg.query("Sex == 'Male'")            elif "Females" in grp_pick2:                df_avg = df_avg.query("Sex == 'Female'")        # Set up the filtering and list for graphing.    if "Male" in comp_pick:        query_col = "Sex"    elif "Treadmill" in comp_pick:        query_col = "ExMode"    elif "Healthy" in comp_pick:        if int_in_cvd_cat == "Yes":            query_col = "CVDcategory"            # Sort df so that options displayed are in order chosen by user.            # Sorting by list comes from Stack Overflow:            # https://stackoverflow.com/questions/23482668/sorting-by-a-custom-list-in-pandas            sorter = cvd_categories            sorterIndex = dict(zip(sorter, range(len(sorter))))            df_avg['cat_rank'] = df_avg['CVDcategory'].map(sorterIndex)            # Also don't have full data for all modes/sexes/ages.            # So, need to put cvd cat with less data at end of df             # This then plots across ages correctly.            df_avg["cnt"] = df_avg.groupby('CVDcategory')['CVDcategory'].transform('count')            df_avg.sort_values(["cnt", "cat_rank", "AgeGroup"],                                ascending=[False,True, True], inplace=True)                    else:            query_col = "CVDstatus"    elif "Regions" in comp_pick:        query_col = "CensusRegion"        # Sort df so that options displayed are in order chosen by user.        # Sorting by list comes from Stack Overflow:        # https://stackoverflow.com/questions/23482668/sorting-by-a-custom-list-in-pandas        sorter = regions        sorterIndex = dict(zip(sorter, range(len(sorter))))        df_avg['reg_rank'] = df_avg['CensusRegion'].map(sorterIndex)        # Also don't have full data for all modes/sexes/ages.        # So, need to put cvd cat with less data at end of df         # This then plots across ages correctly.        df_avg["cnt"] = df_avg.groupby('CensusRegion')['CensusRegion'].transform('count')        df_avg.sort_values(["cnt", "reg_rank", "AgeGroup"],                                ascending=[False,True, True], inplace=True)               # Plot!    # But leave blank if no region selected.    if "Regions" in comp_pick and len(regions) == 0:        st.error("Select at least one region above to see the graph")    elif int_in_cvd_cat == "Yes" and len(cvd_categories) == 0:        st.error("Select at least one cardiovascular disease category above \                 to see the graph")    else:        fig = line(            data_frame = df_avg,            x = df_avg["AgeGroup"],            y = round(df_avg["VO2_rel"],1),            error_y = df_avg["VO2_rel_std"],            error_y_mode = 'band',            color = df_avg[query_col],            title = "VO2max Trends in US Adults",            markers = '.',            labels=dict(y="VO2max (ml/kg/min)",                        AgeGroup="Age Group (years)")        )                st.plotly_chart(fig)        st.write("""        _The line on the graph indicates the average while the shaded area         represents the standard deviation. Hover over a point to view the         average values for that age group._        """)            if int_in_cvd_cat == "Yes":        st.info("""        **_The CABG category includes those who also reported MI but does not \        include those who reported PCI or HF.         The PCI category excludes individuals who also reported CABG, MI, or HF.         The MI category does not include individuals who also reported CABG \        or HF.         The HF category does not exclude those who reported occurrence of \        any other CVD category._        """)                    ###### Create summary line graphs for non-VO2max metrics.    st.write('''    ### Trends for other health metrics:    _(Note: metrics are only from individuals who completed a treadmill \      exercise test)_    ''')        # Determine the variable of interest to graph.    var_int = st.radio("What metric are you interested in?",                        ("Maximum Heart Rate",                        "Resting Systolic Blood Pressure",                        "Height", "Weight",                        "BMI"), index=0)        if var_int == "BMI":        st.write("_You can determine your own BMI at the bottom of this page \                 (below the graph)._")        with open('./data/line_graph_other_metrics.pickle', 'rb') as to_read:            df = pickle.load(to_read)        if "Pressure" in var_int:        y_label = var_int + " (mmHg)"        var_int = "RestingSBP"    elif "Heart" in var_int:        y_label = var_int + " (beats/min)"        var_int = "MaxHR"    elif "Height" in var_int:        y_label = var_int + " (inches)"    elif "Weight" in var_int:        y_label = var_int + " (lbs)"    else:        y_label = var_int + " (kg/m2)"        var_int_SD = var_int + "_std"    fig = line(            data_frame = df,            x = df["AgeGroup"],            y = round(df[var_int],1),            error_y = df[var_int_SD],            error_y_mode = 'band',            color = df["Sex"],            markers = '.',            title = f"{y_label.split('(')[0]}in US Adults",            labels=dict(y=y_label,                        AgeGroup="Age Group (years)")        )            st.plotly_chart(fig)    st.write("""    _The line on the graph indicates the average while the shaded area     represents the standard deviation. Hover over a point to view the     average values for that age group._    """)        ###### Create a BMI calculator.    st.write("""     #### Determine your BMI             """)        units = st.radio("Would you like to use metric or imperial units?",             ("Imperial", "Metric"), index=0)        col1, col2 = st.columns(2)    if units == "Imperial":        with col1:            ht = st.selectbox("Select your height:",                                       ("5 ft, 0 in", "5ft, 1 in",                                       "5 ft, 2 in", "5ft, 3 in",                                       "5 ft, 4 in", "5ft, 5 in",                                       "5 ft, 6 in", "5ft, 7 in",                                       "5 ft, 8 in", "5ft, 9 in",                                       "5 ft, 10 in", "5ft, 11 in",                                       "6 ft, 0 in", "6ft, 1 in",                                       "6 ft, 2 in", "6ft, 3 in",                                       "6 ft, 4 in", "6ft, 5 in",                                       "6 ft, 6 in", "6ft, 7 in",                                       "6 ft, 8 in", "6ft, 9 in",                                       "6 ft, 10 in", "6ft, 11 in"), index=7)            ht = (int(ht.split(", ")[0][0]) * 12) + (int(ht.split(", ")[1][:2]))                with col2:            wt = st.slider("Select your weight (in lbs):", min_value=(40),                               max_value=(350), value=(170), step=(1))        bmi = round((wt/(ht*ht))*703, 1)            else:         with col1:            ht = st.slider("Select your height (in meters):", min_value=(1.5),                               max_value=(2.1), value=(1.75), step=(.01))                 with col2:            wt = st.slider("Select your weight (in kg):", min_value=(18.0),                               max_value=(159.0), value=(80.0), step=(.5))         bmi = round(wt/(ht*ht), 1)     if bmi < 18.5:        bmi_cat = "underweight"    elif bmi >= 30:        bmi_cat = "obese"    elif bmi >= 25:        bmi_cat = "overweight"    else:        bmi_cat = "healthy"      st.write(f"##### Your BMI is: {bmi} kg/m2 ({bmi_cat})")    